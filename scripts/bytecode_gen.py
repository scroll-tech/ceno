# Generated by ChatGPT

# Mapping of opcodes to their hexadecimal representations (only those used in fibonacci contract)
opcode_to_byte = {
    # Stack operations
    'PUSH1': '60',  # (60-7f) PUSH1-PUSH32 have dynamic codes depending on the bytes pushed
    'POP': '50',
    'SWAP1': '90',  # (90-9f) SWAP1-SWAP16 have dynamic codes
    'DUP1': '80',   # (80-8f) DUP1-DUP16 have dynamic codes
    'SWAP2': '91',
    'DUP2': '81',
    'SWAP4': '93',

    # Arithmetic operations
    'GT': '11',
    'ADD': '01',

    # Branch operations
    'JUMPI': '57',
    'JUMP': '56',

    # Memory operations
    'MSTORE': '52',

    # Others
    'CALLDATALOAD': '35',
    'JUMPDEST': '5b',
    'RETURN': 'f3'
}

def convert_opcodes_to_bytecode(opcodes):
    bytecode = ''
    for opcode in opcodes:
        # Split opcode and its possible argument
        parts = opcode.split()
        code = parts[0]
        if code in opcode_to_byte:
            bytecode += opcode_to_byte[code]
            # Add the argument for PUSH operations
            if code.startswith('PUSH'):
                bytecode += parts[1]
        else:
            raise ValueError(f"Unknown opcode: {code}")
    return bytecode

# Example usage
opcode_sequence = [
    'PUSH1 00',
    'CALLDATALOAD',
    'PUSH1 01',
    'PUSH1 00',
    'SWAP2',
    'PUSH1 02',
    'JUMPDEST',
    'DUP2',
    'DUP2',
    'GT',
    'PUSH1 1c',
    'JUMPI',
    'PUSH1 01',
    'ADD',
    'SWAP2',
    'DUP1',
    'SWAP4',
    'ADD',
    'SWAP2',
    'PUSH1 0a',
    'JUMP',
    'JUMPDEST',
    'POP',
    'POP',
    'PUSH1 00',
    'MSTORE',
    'PUSH1 20',
    'PUSH1 00',
    'RETURN',
]
bytecode = convert_opcodes_to_bytecode(opcode_sequence)
print(bytecode)
