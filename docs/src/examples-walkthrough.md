# Walkthroughs of Examples

This chapter will contain detailed walkthroughs of selected examples from the `examples/` directory.

## Fibonacci

The `fibonacci` example computes the `n`-th Fibonacci number, where `n` is a power of 2. The purpose of this example is to show how to perform a simple computation within the zkVM.

### Guest Code

The guest program for the `fibonacci` example is located at `examples/examples/fibonacci.rs`.

```rust
{{#include ../../examples/examples/fibonacci.rs}}
```

The guest program reads a private input `log_n` from the host. This input determines the number of iterations to perform. The program then calculates `n = 1 << log_n` and computes the `n`-th Fibonacci number using a standard iterative approach. To prevent the numbers from growing too large, the computation is performed modulo 7919. Finally, the program commits the result back to the host as a public output.

This example demonstrates the basic workflow of a Ceno zkVM program: reading private inputs, performing computations, and committing public outputs. It shows that you can write standard Rust code for the guest, and the zkVM will execute it.

## Is Prime

The `is_prime` example counts the number of prime numbers up to a given integer `n`. This example showcases a slightly more complex algorithm and control flow.

### Guest Code

The guest program for the `is_prime` example is located at `examples/examples/is_prime.rs`.

```rust
{{#include ../../examples/examples/is_prime.rs}}
```

The guest program reads an integer `n` from the host. It then iterates from 0 to `n`, checking if each number is prime using a helper function `is_prime`. The `is_prime` function implements the trial division method. The total count of prime numbers is accumulated in `cnt_primes`. If the count of primes exceeds a certain threshold, the program will panic. This demonstrates how to handle exceptional cases in the guest. The program does not commit any public output, but the proof generated by the zkVM still guarantees that the computation was performed correctly.

This example highlights the ability to define and use helper functions within the guest code, as well as the use of control flow constructs like loops and conditional statements.

## BN254 Curve Syscalls

The `bn254_curve_syscalls` example demonstrates the use of syscalls for elliptic curve operations on the BN254 curve. This is useful for cryptographic applications that require curve arithmetic.

### Guest Code

The guest program for the `bn254_curve_syscalls` example is located at `examples/examples/bn254_curve_syscalls.rs`.

```rust
{{#include ../../examples/examples/bn254_curve_syscalls.rs}}
```

The guest program initializes two points on the BN254 curve. It then uses the `syscall_bn254_add` syscall to add the two points and asserts that the result is correct by comparing it with a pre-computed value. It also demonstrates the use of the `syscall_bn254_double` syscall to double a point. The program includes helper functions to convert between different representations of curve points.

This example showcases how to leverage syscalls to perform complex and computationally expensive operations. By using syscalls, the guest can delegate these operations to the host, which can often execute them more efficiently. The guest can still verify the results of the syscalls to ensure the integrity of the computation.

## Ceno RT Alloc

The `ceno_rt_alloc` example shows how to use the allocator in the Ceno runtime to allocate memory on the heap.

### Guest Code

The guest program for the `ceno_rt_alloc` example is located at `examples/examples/ceno_rt_alloc.rs`.

```rust
{{#include ../../examples/examples/ceno_rt_alloc.rs}}
```

The guest program demonstrates three different memory operations. First, it writes to a global static variable. Second, it allocates a small `Vec` on the heap. Third, it allocates a much larger `Vec` on the heap and writes a value to an element in it. The `black_box` function is used to ensure that the compiler does not optimize away these memory operations.

This example is important for understanding how memory management works in the Ceno zkVM. It shows that the guest has access to both static memory and heap memory, and can perform dynamic memory allocation.

## Keccak Syscall

The `keccak_syscall` example demonstrates how to use a syscall to perform the Keccak permutation, which is the core of the Keccak hash function (used in SHA-3).

### Guest Code

The guest program for the `keccak_syscall` example is located at `examples/examples/keccak_syscall.rs`.

```rust
{{#include ../../examples/examples/keccak_syscall.rs}}
```

The guest program initializes a 25-word state and then enters a loop where it repeatedly applies the Keccak permutation to the state using the `syscall_keccak_permute` syscall. The `log_state` function is used to log the state after the first permutation, which can be useful for debugging.

This example further illustrates the power of syscalls. The Keccak permutation is a complex operation, and implementing it efficiently in the guest would be challenging. By providing it as a syscall, the Ceno platform makes it easy for guest programs to use this important cryptographic primitive.

## Median

The `median` example shows how to find the median of a list of numbers. It demonstrates a common pattern where the host provides a candidate answer, and the guest verifies it.

### Guest Code

The guest program for the `median` example is located at `examples/examples/median.rs`.

```rust
{{#include ../../examples/examples/median.rs}}
```

The guest program reads a list of numbers and a median candidate from the host. It then verifies that the candidate is indeed the median by counting the number of elements in the list that are smaller than the candidate. If the count is equal to half the length of the list, the assertion passes, and the program successfully completes.

This example showcases a powerful pattern for zkVM programming: verifiable computation. The host, which is not constrained by the limitations of the zkVM, can perform a complex computation (like finding the median of a large list) and then provide the answer to the guest. The guest's task is then to perform a much simpler computation to verify that the host's answer is correct. This allows for the verification of complex computations that would be too expensive to perform directly in the zkVM.

## Sorting

The `sorting` example demonstrates how to sort a list of numbers inside the guest.

### Guest Code

The guest program for the `sorting` example is located at `examples/examples/sorting.rs`.

```rust
{{#include ../../examples/examples/sorting.rs}}
```

The guest program reads a list of numbers from the host, creates a mutable copy of it, and then sorts the copy using the standard `sort` method from the Rust standard library. The `debug_println!` macro is used to print the first element of the sorted vector, which can be useful for debugging.

This example demonstrates that the Ceno zkVM supports a significant portion of the Rust standard library, including common data structures and algorithms. This makes it easy to write complex programs for the guest, as you can leverage the power and convenience of the standard library.
